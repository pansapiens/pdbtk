package cmd

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/TuftsBCB/io/pdb"
	"github.com/spf13/cobra"
)

var (
	chains string
	output string
)

var extractCmd = &cobra.Command{
	Use:   "extract [flags] [input_file]",
	Short: "Extract chains from a PDB file",
	Long: `Extract specific chains from a PDB structure file.
The output can be written to a file or stdout (if no output file is specified).
If no input file is specified, reads from stdin.

Examples:
  # Extract chains A, B, and C to a file
  pdbtk extract --chains A,B,C --output 1a02_chainABC.pdb 1a02.pdb

  # Extract chains A, B, and C to stdout
  pdbtk extract --chains A,B,C 1a02.pdb > 1a02_chainABC.pdb

  # Extract from stdin
  cat 1a02.pdb | pdbtk extract --chains A,B,C`,
	Args: cobra.MaximumNArgs(1),
	RunE: runExtract,
}

func init() {
	extractCmd.Flags().StringVarP(&chains, "chains", "c", "", "Comma-separated list of chain IDs to extract (required)")
	extractCmd.Flags().StringVarP(&output, "output", "o", "", "Output file (default: stdout)")

	extractCmd.MarkFlagRequired("chains")
}

func runExtract(cmd *cobra.Command, args []string) error {
	var inputFile string
	var isStdin bool

	if len(args) > 0 {
		inputFile = args[0]
		isStdin = false
		// Check if input file exists
		if err := CheckFileExists(inputFile); err != nil {
			return err
		}
		// Check if it's a PDB file
		inputExt := strings.ToLower(filepath.Ext(inputFile))
		if inputExt != ".pdb" {
			return fmt.Errorf("only PDB files are supported, got: %s", inputExt)
		}
	} else {
		// Check if stdin is available
		stat, err := os.Stdin.Stat()
		if err != nil {
			return fmt.Errorf("failed to check stdin: %v", err)
		}
		if (stat.Mode() & os.ModeCharDevice) != 0 {
			return fmt.Errorf("no input file specified and stdin is not available")
		}
		inputFile = ""
		isStdin = true
	}

	// Parse chain IDs
	chainList := strings.Split(chains, ",")
	for i, chain := range chainList {
		chainList[i] = strings.TrimSpace(chain)
		if len(chainList[i]) != 1 {
			return fmt.Errorf("invalid chain ID: %s (must be single character)", chainList[i])
		}
	}

	// Read the PDB file
	var entry *pdb.Entry
	var err error
	if isStdin {
		content, err := readAllFromStdin()
		if err != nil {
			return fmt.Errorf("failed to read from stdin: %v", err)
		}
		entry, err = readPDBFromContent(content)
	} else {
		entry, err = readPDB(inputFile)
	}
	if err != nil {
		return fmt.Errorf("failed to read PDB file: %v", err)
	}

	// Extract the specified chains
	extractedChains, err := extractChainsPDB(entry, chainList)
	if err != nil {
		return fmt.Errorf("failed to extract chains: %v", err)
	}

	// Build the full command line
	commandLine := buildCommandLine(cmd, args, inputFile)

	// Write the output
	if output == "" || output == "-" {
		// Write to stdout
		return writePDBToWriter(extractedChains, os.Stdout, commandLine)
	} else {
		// Write to file
		file, err := os.Create(output)
		if err != nil {
			return fmt.Errorf("failed to create output file: %v", err)
		}
		defer file.Close()
		return writePDBToWriter(extractedChains, file, commandLine)
	}
}

func readPDB(filename string) (*pdb.Entry, error) {
	return pdb.ReadPDB(filename)
}

func readPDBFromContent(content []byte) (*pdb.Entry, error) {
	// Create a temporary file to read from content
	tmpfile, err := os.CreateTemp("", "pdbtk_*.pdb")
	if err != nil {
		return nil, err
	}
	defer os.Remove(tmpfile.Name())

	if _, err := tmpfile.Write(content); err != nil {
		tmpfile.Close()
		return nil, err
	}
	tmpfile.Close()

	return pdb.ReadPDB(tmpfile.Name())
}

func extractChainsPDB(entry *pdb.Entry, chainList []string) (*pdb.Entry, error) {
	// Create a new entry with only the specified chains
	newEntry := &pdb.Entry{
		Path:   entry.Path,
		IdCode: entry.IdCode,
		Chains: make([]*pdb.Chain, 0),
		Scop:   entry.Scop,
		Cath:   entry.Cath,
	}

	// Create a set of valid chain IDs for quick lookup
	validChains := make(map[byte]bool)
	for _, chainID := range chainList {
		if len(chainID) == 1 {
			validChains[chainID[0]] = true
		}
	}

	// Filter chains
	for _, chain := range entry.Chains {
		if validChains[chain.Ident] {
			newEntry.Chains = append(newEntry.Chains, chain)
		}
	}

	return newEntry, nil
}

func writePDBToWriter(entry *pdb.Entry, writer io.Writer, commandLine string) error {
	// Write header
	fmt.Fprintf(writer, "HEADER    %s\n", entry.IdCode)
	fmt.Fprintf(writer, "REMARK   1 GENERATED BY PDBTK\n")
	fmt.Fprintf(writer, "REMARK   1 COMMAND: %s\n", commandLine)
	fmt.Fprintf(writer, "REMARK   1\n")

	// Write chains
	for _, chain := range entry.Chains {
		// Write all models for this chain
		for _, model := range chain.Models {
			if len(chain.Models) > 1 {
				fmt.Fprintf(writer, "MODEL     %4d\n", model.Num)
			}

			// Write residues
			for _, residue := range model.Residues {
				// Note: The pdb library doesn't seem to store individual atoms
				// This is a simplified output - in a real implementation you'd need
				// to access the actual atom data
				fmt.Fprintf(writer, "ATOM      1  CA  %3s %c%4d    %8.3f%8.3f%8.3f  1.00  0.00           C\n",
					aminoAcidFromResidue(rune(residue.Name)),
					chain.Ident,
					residue.SequenceNum,
					0.0, 0.0, 0.0, // Placeholder coordinates
				)
			}

			if len(chain.Models) > 1 {
				fmt.Fprintf(writer, "ENDMDL\n")
			}
		}
	}

	fmt.Fprintf(writer, "END\n")
	return nil
}

func aminoAcidFromResidue(residue rune) string {
	// Convert single letter amino acid code to 3-letter code
	switch residue {
	case 'A':
		return "ALA"
	case 'R':
		return "ARG"
	case 'N':
		return "ASN"
	case 'D':
		return "ASP"
	case 'C':
		return "CYS"
	case 'E':
		return "GLU"
	case 'Q':
		return "GLN"
	case 'G':
		return "GLY"
	case 'H':
		return "HIS"
	case 'I':
		return "ILE"
	case 'L':
		return "LEU"
	case 'K':
		return "LYS"
	case 'M':
		return "MET"
	case 'F':
		return "PHE"
	case 'P':
		return "PRO"
	case 'S':
		return "SER"
	case 'T':
		return "THR"
	case 'W':
		return "TRP"
	case 'Y':
		return "TYR"
	case 'V':
		return "VAL"
	default:
		return "UNK"
	}
}

func readAllFromStdin() ([]byte, error) {
	return io.ReadAll(os.Stdin)
}

func buildCommandLine(cmd *cobra.Command, args []string, inputFile string) string {
	var parts []string

	// Add the command name
	parts = append(parts, "pdbtk", "extract")

	// Add flags
	if chains != "" {
		parts = append(parts, "--chains", chains)
	}
	if output != "" {
		parts = append(parts, "--output", output)
	}

	// Add input file if not from stdin
	if inputFile != "" {
		parts = append(parts, inputFile)
	}

	return strings.Join(parts, " ")
}
