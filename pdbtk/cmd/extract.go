package cmd

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/TuftsBCB/io/pdb"
	"github.com/spf13/cobra"
)

var (
	chains string
	output string
)

var extractCmd = &cobra.Command{
	Use:   "extract [flags] [input_file]",
	Short: "Extract chains from a PDB file",
	Long: `Extract specific chains from a PDB structure file.
The output can be written to a file or stdout (if no output file is specified).
If no input file is specified, reads from stdin.

Examples:
  # Extract chains A, B, and C to a file
  pdbtk extract --chains A,B,C --output 1a02_chainABC.pdb 1a02.pdb

  # Extract chains A, B, and C to stdout
  pdbtk extract --chains A,B,C 1a02.pdb > 1a02_chainABC.pdb

  # Extract from stdin
  cat 1a02.pdb | pdbtk extract --chains A,B,C`,
	Args: cobra.MaximumNArgs(1),
	RunE: runExtract,
}

func init() {
	extractCmd.Flags().StringVarP(&chains, "chains", "c", "", "Comma-separated list of chain IDs to extract (required)")
	extractCmd.Flags().StringVarP(&output, "output", "o", "", "Output file (default: stdout)")

	extractCmd.MarkFlagRequired("chains")
}

func runExtract(cmd *cobra.Command, args []string) error {
	var inputFile string
	var isStdin bool

	if len(args) > 0 {
		inputFile = args[0]
		isStdin = false
		// Check if input file exists
		if err := CheckFileExists(inputFile); err != nil {
			return err
		}
		// Check if it's a PDB file
		inputExt := strings.ToLower(filepath.Ext(inputFile))
		if inputExt != ".pdb" {
			return fmt.Errorf("only PDB files are supported, got: %s", inputExt)
		}
	} else {
		// Check if stdin is available
		stat, err := os.Stdin.Stat()
		if err != nil {
			return fmt.Errorf("failed to check stdin: %v", err)
		}
		if (stat.Mode() & os.ModeCharDevice) != 0 {
			return fmt.Errorf("no input file specified and stdin is not available")
		}
		inputFile = ""
		isStdin = true
	}

	// Parse chain IDs
	chainList := strings.Split(chains, ",")
	for i, chain := range chainList {
		chainList[i] = strings.TrimSpace(chain)
		if len(chainList[i]) != 1 {
			return fmt.Errorf("invalid chain ID: %s (must be single character)", chainList[i])
		}
	}

	// Read the PDB file
	var entry *pdb.Entry
	var err error
	if isStdin {
		content, err := readAllFromStdin()
		if err != nil {
			return fmt.Errorf("failed to read from stdin: %v", err)
		}
		entry, err = readPDBFromContent(content)
	} else {
		entry, err = readPDB(inputFile)
	}
	if err != nil {
		return fmt.Errorf("failed to read PDB file: %v", err)
	}

	// Extract the specified chains
	extractedChains, err := extractChainsPDB(entry, chainList)
	if err != nil {
		return fmt.Errorf("failed to extract chains: %v", err)
	}

	// Build the full command line
	commandLine := buildCommandLine(cmd, args, inputFile)

	// Write the output
	if output == "" || output == "-" {
		// Write to stdout
		return writePDBToWriter(extractedChains, os.Stdout, commandLine)
	} else {
		// Write to file
		file, err := os.Create(output)
		if err != nil {
			return fmt.Errorf("failed to create output file: %v", err)
		}
		defer file.Close()
		return writePDBToWriter(extractedChains, file, commandLine)
	}
}

func readPDB(filename string) (*pdb.Entry, error) {
	return pdb.ReadPDB(filename)
}

func readPDBFromContent(content []byte) (*pdb.Entry, error) {
	// Create a temporary file to read from content
	tmpfile, err := os.CreateTemp("", "pdbtk_*.pdb")
	if err != nil {
		return nil, err
	}
	defer os.Remove(tmpfile.Name())

	if _, err := tmpfile.Write(content); err != nil {
		tmpfile.Close()
		return nil, err
	}
	tmpfile.Close()

	return pdb.ReadPDB(tmpfile.Name())
}

func extractChainsPDB(entry *pdb.Entry, chainList []string) (*pdb.Entry, error) {
	// Create a new entry with only the specified chains
	newEntry := &pdb.Entry{
		Path:   entry.Path,
		IdCode: entry.IdCode,
		Chains: make([]*pdb.Chain, 0),
		Scop:   entry.Scop,
		Cath:   entry.Cath,
	}

	// Create a set of valid chain IDs for quick lookup
	validChains := make(map[byte]bool)
	for _, chainID := range chainList {
		if len(chainID) == 1 {
			validChains[chainID[0]] = true
		}
	}

	// Filter chains
	for _, chain := range entry.Chains {
		if validChains[chain.Ident] {
			newEntry.Chains = append(newEntry.Chains, chain)
		}
	}

	return newEntry, nil
}

func writePDBToWriter(entry *pdb.Entry, writer io.Writer, commandLine string) error {
	// Write header
	fmt.Fprintf(writer, "HEADER    %s\n", entry.IdCode)
	fmt.Fprintf(writer, "REMARK   1 GENERATED BY PDBTK\n")
	fmt.Fprintf(writer, "REMARK   1 COMMAND: %s\n", commandLine)
	fmt.Fprintf(writer, "REMARK   1\n")

	// Check if any chain has multiple models (ensemble) to determine if we need MODEL/ENDMDL records
	hasMultipleModels := false
	for _, chain := range entry.Chains {
		if len(chain.Models) > 1 {
			hasMultipleModels = true
			break
		}
	}

	atomSerial := 1
	for _, chain := range entry.Chains {
		for _, model := range chain.Models {
			// Only output MODEL record if we have multiple models (ensemble)
			if hasMultipleModels {
				fmt.Fprintf(writer, "MODEL     %4d\n", model.Num)
			}

			for _, residue := range model.Residues {
				for _, atom := range residue.Atoms {
					recordType := "ATOM  "
					if atom.Het {
						recordType = "HETATM"
					}
					// Handle insertion code - use space if it's null byte
					insertionCode := residue.InsertionCode
					if insertionCode == 0 {
						insertionCode = ' '
					}

					formattedAtomName := formatAtomName(atom.Name)

					fmt.Fprintf(writer, "%-6s%5d %s%c%3s %c%4d%c   %8.3f%8.3f%8.3f%6.2f%6.2f          %2s\n",
						recordType,        // 1-6: "ATOM  " or "HETATM"
						atomSerial,        // 7-11: atom serial number
						formattedAtomName, // 13-16: atom name
						' ',               // 17: alternate location indicator
						singleLetterToResidue(string(residue.Name)), // 18-20: residue name
						chain.Ident,                                 // 22: chain identifier
						residue.SequenceNum,                         // 23-26: residue sequence number
						insertionCode,                               // 27: insertion code
						atom.Coords.X, atom.Coords.Y, atom.Coords.Z, // 31-38, 39-46, 47-54: coordinates
						1.00, 20.00, // 55-60, 61-66: occupancy and temperature factor
						extractElementSymbol(atom.Name), // 77-78: element symbol
					)
					atomSerial++
				}
			}

			// Only output ENDMDL record if we have multiple models (ensemble)
			if hasMultipleModels {
				fmt.Fprintf(writer, "ENDMDL\n")
			}
		}
	}

	fmt.Fprintf(writer, "END\n")
	return nil
}

func aminoAcidFromResidue(residue rune) string {
	// Convert single letter amino acid code to 3-letter code
	switch residue {
	case 'A':
		return "ALA"
	case 'R':
		return "ARG"
	case 'N':
		return "ASN"
	case 'D':
		return "ASP"
	case 'C':
		return "CYS"
	case 'E':
		return "GLU"
	case 'Q':
		return "GLN"
	case 'G':
		return "GLY"
	case 'H':
		return "HIS"
	case 'I':
		return "ILE"
	case 'L':
		return "LEU"
	case 'K':
		return "LYS"
	case 'M':
		return "MET"
	case 'F':
		return "PHE"
	case 'P':
		return "PRO"
	case 'S':
		return "SER"
	case 'T':
		return "THR"
	case 'W':
		return "TRP"
	case 'Y':
		return "TYR"
	case 'V':
		return "VAL"
	default:
		return "UNK"
	}
}

// extractElementSymbol extracts the element symbol from an atom name
func extractElementSymbol(atomName string) string {
	// Remove leading digits and spaces, then take the first letter
	atomName = strings.TrimSpace(atomName)
	if len(atomName) == 0 {
		return ""
	}

	// Find the first alphabetic character
	for i, char := range atomName {
		if (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z') {
			// Take the first letter and optionally the second if it's lowercase
			if i+1 < len(atomName) && atomName[i+1] >= 'a' && atomName[i+1] <= 'z' {
				return strings.ToUpper(atomName[i : i+2])
			}
			return strings.ToUpper(string(char))
		}
	}

	// Fallback: return the first character if no alphabetic character found
	if len(atomName) > 0 {
		return strings.ToUpper(string(atomName[0]))
	}
	return ""
}

// singleLetterToResidue converts single-letter amino acid codes to three-letter codes
func singleLetterToResidue(singleLetter string) string {
	// Convert to uppercase for consistency
	singleLetter = strings.ToUpper(singleLetter)

	// Reverse mapping from single letter to three letter codes
	reverseMap := map[string]string{
		"A": "ALA", "R": "ARG", "N": "ASN", "D": "ASP", "C": "CYS",
		"Q": "GLN", "E": "GLU", "G": "GLY", "H": "HIS", "I": "ILE",
		"L": "LEU", "K": "LYS", "M": "MET", "F": "PHE", "P": "PRO",
		"S": "SER", "T": "THR", "W": "TRP", "Y": "TYR", "V": "VAL",
		// Modified amino acids and common variants
		"U": "SEC", "O": "PYL", // Selenocysteine and Pyrrolysine
		"X": "UNK", "J": "XLE", // Unknown amino acids
	}

	if threeLetter, exists := reverseMap[singleLetter]; exists {
		return threeLetter
	}

	// If not found, return UNK for unknown
	return "UNK"
}

// formatAtomName formats the atom name for PDB output according to spec.
// Columns 13-16: Atom name.
// Details: Element symbol right-justified in 13-14.
//
//	Trailing characters left-justified in 15-16.
//	Single-char element symbol should be in column 14, unless atom name is 4 chars.
func formatAtomName(atomName string) string {
	name := strings.TrimSpace(atomName)
	element := extractElementSymbol(name)

	// Rule: If an atom name has four characters, it must start in column 13
	if len(name) >= 4 {
		return fmt.Sprintf("%-4s", name)
	}

	// Rule: single-character element symbol should not appear in column 13
	if len(element) == 1 {
		// Place element in column 14.
		trailing := strings.TrimPrefix(name, element)
		return fmt.Sprintf(" %-1s%-2s", element, trailing)
	}

	// Rule: element symbols right-justified in columns 13-14.
	if len(element) == 2 {
		trailing := strings.TrimPrefix(name, element)
		return fmt.Sprintf("%-2s%-2s", element, trailing)
	}

	// Fallback for weird cases, just left-justify.
	return fmt.Sprintf("%-4s", name)
}

func readAllFromStdin() ([]byte, error) {
	return io.ReadAll(os.Stdin)
}

func buildCommandLine(cmd *cobra.Command, args []string, inputFile string) string {
	var parts []string

	// Add the command name
	parts = append(parts, "pdbtk", "extract")

	// Add flags
	if chains != "" {
		parts = append(parts, "--chains", chains)
	}
	if output != "" {
		parts = append(parts, "--output", output)
	}

	// Add input file if not from stdin
	if inputFile != "" {
		parts = append(parts, inputFile)
	}

	return strings.Join(parts, " ")
}
